{
  "name": "modella",
  "version": "0.2.6",
  "description": "simplified models",
  "keywords": [
    "modella",
    "models"
  ],
  "author": {
    "name": "matthew mueller",
    "email": "mattmuelle@gmail.com"
  },
  "dependencies": {
    "emitter-component": "1.0.1",
    "is-browser": "~2.0.0"
  },
  "devDependencies": {
    "mocha": "*",
    "expect.js": "*",
    "express": "*"
  },
  "scripts": {
    "test": "make test"
  },
  "readme": "# modella [![Build Status](https://secure.travis-ci.org/modella/modella.png?branch=master)](http://travis-ci.org/modella/modella)\n\n  Highly extendable bloat-free models.\n\n## Installation\n\nWith node.js:\n\n    npm install modella\n\nIn the browser (using [component](https://github.com/component/component)):\n\n    component install modella/modella\n\n## Philosophy\n\n`modella` is a bare bones model. It exposes a few APIs on which plugins can be\nbuilt to enhance functionality. Usage of these plugins enables high-powered but\nbloat free models.\n\nCheck out the [list of available\nplugins](https://github.com/modella/modella/wiki/List-of-Modella-Plugins)\n\n# Defining Models\n\nAll `modella` definition methods are chainable.\n\n### modella( name )\n\nCreates a new model with the name `name`.\n\n```js\nvar modella = require('modella');\nvar User = modella('User');\n```\n\n### Model.use ( [env], fn )\n\nAs mentioned in the philosophy, `modella`'s goal is to make it easy to extend\nmodels with plugins. This lets you create models that do exactly what you need,\nand nothing more. You can use `env` to target the client and the server separately.\n\n```js\nvar modella = require('modella');\nvar validators = require('modella-validators');\nvar User = modella('User');\n\nUser.use(validators);\n```\n\nBrowser plugin:\n\n```js\nUser.use('client', plugin);\n// or\nUser.use('browser', plugin);\n```\n\nServer plugin:\n\n```js\nUser.use('server', plugin);\n// or\nUser.use('node', plugin);\n```\n\n### Model.attr( name, [options] )\n\nAdds attribute `attrName` to a model. Additional `options` can be passed in as\nan object. Modella does not use these options, but plugins may.\n\n```js\nvar modella = require('modella'),\nvar validators = require('modella-validators'),\nvar User = modella('User');\n\nUser.use(validators);\n\nUser\n  .attr('_id')\n  .attr('username', { required: true })\n  .attr('email', { required: true, format: 'email' });\n```\n\n### Model.validate( fn )\n\nAdds a validator to the model. A validator should add error messages for\nattributes that fail validation. Note that plugins such as\n[modella/validators](http://github.com/modella/validators) make extensive use of\nthis.\n\n```js\nvar User = modella('User');\n\nUser.validate(function(user) {\n  if(!user.username()) {\n    user.error('username', \"is required\");\n  }\n});\n```\n\n# Working with Instances\n\n### new Model( [attrs] )\n\nYou can create instances of models with the `new` operator. You can also specify\ninitial values by passing in an object for `attrs`.\n\n```js\nvar user = new User();\n\nvar bob = new User({username: 'Bob' });\n```\n\n### Model#attribute(value)\n\nSets the given attribute to a value.\n\n```js\nvar user = new User();\n\nuser.username(\"Bob\");\n```\n\n### Model#attribute()\n\nReturns the value of the attribute\n\n```js\nvar user = new User({username: 'Bob'});\n\nuser.username() // => 'Bob'\n```\n\n### Model#get( attr )\n\nReturns the value of the attribute\n\n```js\nvar user = new User({username: 'Bob'});\n\nuser.get('username') // => 'Bob'\n```\n\n### Model#has( attr )\n\nReturns whether an instance has an attribute set.\n\n```js\nvar user = new User({username: 'Bob'});\n\nuser.has('email') // => false\n```\n\n### Model#set( attrs )\n\nQuickly sets multiple attributes.\n\n```js\nvar user = new User();\n\nuser.set({username: 'Bob', email: 'bob@bobbington.com'});\n```\n\n### Model#primary( [key] )\n\nGets or sets the value of the primary `key` attribute. By default, this auto-maps to an\nattribute with the name of `_id` or `id` if it is specified.\n\nGetting the primary key:\n\n```js\nvar User = modella('User').attr('_id');\nvar user = new User({_id: 123 });\n\nuser.primary(); // => 123\n```\n\nSetting the primary key:\n\n```js\nvar User = modella('User').attr('_id');\nvar user = new User({_id: 123 });\nuser.primary(456);\n\nuser.primary(); // => 456\n```\n\n### Model#isNew()\n\nReturns a boolean based on if the value of `Model#primary()` is set or not.\n\n```js\nvar user = new User();\nuser.isNew() // => true\n\nvar oldUser = new User({_id: 555});\noldUser.isNew() // => false\n```\n\n### Model.isValid()\n\nRuns all validators on the model and returns whether any validations failed.\n\n```js\nvar User = modella('User')\nvar validators = require('modella-validators');\n\nUser\n  .attr('username', { required: true })\n  .use(validators);\n\nvar user = new User();\n\nuser.isValid() // => false\n```\n\n### Model#save( [fn(err)] )\n\nSaves the model using the `syncLayer`. Will not attempt to save if\n`model#isValid()` returns false.\n\nCalls `fn(err)` after save.\n\n```js\nvar User = modella('User')\n  .attr('_id')\n  .attr('name');\n\nvar user = new User({ name: 'Charley' });\n\nuser.save(function(err) {\n  // ...\n});\n```\n\nUsing events:\n\n```js\nuser.on('save', function() {\n  // all good!\n});\n\nuser.on('error', function(err) {\n  // oh no!\n});\n\nuser.save();\n```\n\n### Model#remove( [fn(err)] )\n\nDeletes the model using the sync layer and marks it as `removed`.\n\nCalls `fn(err)` after remove.\n\n### Model#removed\n\nMarked as true if the model has been deleted.\n\n```js\nuser.remove(function(err) {\n  // ...\n});\n\nuser.removed // => true\n```\n\n### Model#model\n\nPoints to the base model from which the instance was created.\n\n```js\nvar user = new User();\n\nuser.model === User // => true\n```\n\n# Writing Plugins\n\nModella is made to be extended! Use events to hook into modella and manipulate\nthe data as necessary. See below for the list of events.\n\nFor types of plugins, and more comprehensive documentation, see the [plugin writing\nguide](https://github.com/modella/modella/wiki/Plugin-Writing-Guide).\n\nHere's some existing plugins to help you get started: [list of available\nplugins](https://github.com/modella/modella/wiki/List-of-Modella-Plugins).\n\n# Events\n\nAll modella models have built in emitters on both instances and the model\nitself.\n\nYou can listen for an event on either the `instance` of a model or the `Model` itself. Here's how to listen on the instance:\n\n```js\nvar user = new User()\n\nuser.on('save', function() {\n  user.remove();\n});\n```\n\nListening on the `Model` is useful for performing aggregate operations on all instances. Here's how to listen on the `Model`:\n\n```js\nUser.on('save', function(user) {\n  // user is the instance that performed save\n});\n```\n\n## List of All Events\n\n### Save Events\n\n- `save` triggers after a successful save.\n- `create` triggers after a record is saved for the first time.\n- `saving` triggers before saving has occurred. `saving` requires asynchronous callbacks so that validation can occur.\n\nAsynchronous callback:\n\n```js\nuser.on('saving', function(done) {\n  // ...\n  done();\n});\n\nUser.on('saving', function(user, done) {\n  // ...\n  done();\n});\n```\n\n### Remove Events\n\n- `remove`: triggers after a successful removal.\n- `removing`: triggers before a remove has occurred. `removing` must call an\n  asynchronous callback so that execution can continue\n\nAsynchronous callback:\n\n```js\nuser.on('removing', function(done) {\n  // ...\n  done();\n});\n\nUser.on('removing', function(user, done) {\n  // ...\n  done();\n});\n```\n\n### Validation Events\n\n- `invalid` triggers when `isValid()` or `validate()` fails.\n- `valid` triggers when `isValid()` or `validate()` passes.\n\n### Manipulation Events\n\n- `change <attr>` triggers when `attr` changes (via `set` or\n  `model.attr(val)`.\n\n```js\nuser.on('change name', function(val, prev) {\n  // ...\n})\n\nuser.name('charley');\n```\n\n- `initializing` triggers when a new `instance` is created. Passes `attrs` which\n  can be modified by the listener.\n\n```js\nUser.on('initializing', function(instance, attrs) {\n  attrs.name = attrs.name.toUpperCase();\n});\n\nvar bob = new User({name: 'Bob'});\nbob.name() // => BOB\n```\n\n- `setting` triggers when `instance.set` is called. Passes `attrs` which can\n  be modified in the listener.\n\n```js\nUser.on('setting', function(instance, attrs) {\n  attrs.name = attrs.name.toUpperCase();\n});\nvar bob = new User();\nbob.set({name: 'Bob'});\nbob.name() // => BOB\n```\n\n### Miscellaneous Events\n\n- `attr` triggers when a new attribute is added/changed (`Model.attr(name, options)`)\n- `initialize` triggers when a model has been completely initialized.\n- `error` triggers whenever there's an error syncing the model.\n\n# License\n\n(The MIT License)\n\nCopyright (c) 2013 Ryan Schmukler <ryan@slingingcode.com>\n\nCopyright (c) 2013 Matthew Mueller <mattmuelle@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the 'Software'), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "Readme.md",
  "_id": "modella@0.2.6",
  "_from": "modella@"
}
